/** 
 * tests the query aspect of an item that falls int he middle of two lane jumps
 */
@Test public void queryMiddleItem(){
  MockOrderedContentMirrorStoreStrategy ascending=new MockOrderedContentMirrorStoreStrategy(OrderDirection.ASC);
  MockOrderedContentMirrorStoreStrategy descending=new MockOrderedContentMirrorStoreStrategy(OrderDirection.DESC);
  NodeBuilder index;
  final String propertyName="property";
  Iterator<String> resultset;
  FilterImpl filter;
  NodeBuilder indexMeta;
  index=EmptyNodeState.EMPTY_NODE.builder();
  ascending.setLane(0);
  ascending.update(index,"/path/a",EMPTY_KEY_SET,newHashSet(KEYS[0]));
  ascending.setLane(1);
  ascending.update(index,"/path/b",EMPTY_KEY_SET,newHashSet(KEYS[1]));
  ascending.setLane(0);
  ascending.update(index,"/path/c",EMPTY_KEY_SET,newHashSet(KEYS[2]));
  ascending.setLane(2);
  ascending.update(index,"/path/d",EMPTY_KEY_SET,newHashSet(KEYS[3]));
  ascending.setLane(0);
  ascending.update(index,"/path/e",EMPTY_KEY_SET,newHashSet(KEYS[4]));
  ascending.update(index,"/path/f",EMPTY_KEY_SET,newHashSet(KEYS[5]));
  printSkipList(index.getNodeState());
  indexMeta=EmptyNodeState.EMPTY_NODE.builder();
  indexMeta.setChildNode(IndexConstants.INDEX_CONTENT_NODE_NAME,index.getNodeState());
  filter=new FilterImpl();
  filter.restrictProperty(propertyName,Operator.GREATER_OR_EQUAL,PropertyValues.newString(KEYS[2]));
  resultset=ascending.query(filter,"indexName",indexMeta.getNodeState(),filter.getPropertyRestriction(propertyName)).iterator();
  assertEquals("path/c",resultset.next());
  assertEquals("path/d",resultset.next());
  assertEquals("path/e",resultset.next());
  assertEquals("path/f",resultset.next());
  assertFalse("We should have not any results left",resultset.hasNext());
  filter=new FilterImpl();
  filter.restrictProperty(propertyName,Operator.LESS_OR_EQUAL,PropertyValues.newString(KEYS[2]));
  resultset=ascending.query(filter,"indexName",indexMeta.getNodeState(),filter.getPropertyRestriction(propertyName)).iterator();
  assertEquals("path/a",resultset.next());
  assertEquals("path/b",resultset.next());
  assertEquals("path/c",resultset.next());
  assertFalse("We should have not any results left",resultset.hasNext());
  index=EmptyNodeState.EMPTY_NODE.builder();
  descending.setLane(0);
  descending.update(index,"/path/a",EMPTY_KEY_SET,newHashSet(KEYS[5]));
  descending.setLane(1);
  descending.update(index,"/path/b",EMPTY_KEY_SET,newHashSet(KEYS[4]));
  descending.setLane(0);
  descending.update(index,"/path/c",EMPTY_KEY_SET,newHashSet(KEYS[3]));
  descending.setLane(2);
  descending.update(index,"/path/d",EMPTY_KEY_SET,newHashSet(KEYS[2]));
  descending.setLane(0);
  descending.update(index,"/path/e",EMPTY_KEY_SET,newHashSet(KEYS[1]));
  descending.update(index,"/path/f",EMPTY_KEY_SET,newHashSet(KEYS[0]));
  printSkipList(index.getNodeState());
  indexMeta=EmptyNodeState.EMPTY_NODE.builder();
  indexMeta.setChildNode(IndexConstants.INDEX_CONTENT_NODE_NAME,index.getNodeState());
  filter=new FilterImpl();
  filter.restrictProperty(propertyName,Operator.GREATER_OR_EQUAL,PropertyValues.newString(KEYS[3]));
  resultset=descending.query(filter,"indexName",indexMeta.getNodeState(),filter.getPropertyRestriction(propertyName)).iterator();
  assertEquals("path/a",resultset.next());
  assertEquals("path/b",resultset.next());
  assertEquals("path/c",resultset.next());
  assertFalse("We should have not any results left",resultset.hasNext());
  filter=new FilterImpl();
  filter.restrictProperty(propertyName,Operator.LESS_OR_EQUAL,PropertyValues.newString(KEYS[3]));
  resultset=descending.query(filter,"indexName",indexMeta.getNodeState(),filter.getPropertyRestriction(propertyName)).iterator();
  assertEquals("path/c",resultset.next());
  assertEquals("path/d",resultset.next());
  assertEquals("path/e",resultset.next());
  assertEquals("path/f",resultset.next());
  assertFalse("We should have not any results left",resultset.hasNext());
}
